<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>–¢–µ—Ç—Ä–∏—Å ‚Äî –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
<style>
  /* === –°—Ç–∏–ª–∏ –¥–ª—è –¢–µ—Ç—Ä–∏—Å–∞ === */
  body {
    margin: 0;
    background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 100%);
    color: #f8fafc;
    font-family: 'Rubik', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  h1 {
    margin: 1rem 0 0.5rem 0;
    font-weight: 700;
  }

  #gameContainer {
    display: flex;
    gap: 2rem;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
    margin-bottom: 2rem;
  }

  canvas {
    background: #111827;
    border-radius: 1rem;
    box-shadow: 0 0 25px #2563eb;
    image-rendering: pixelated;
  }

  #tetrisCanvas {
    width: 300px;
    height: 600px;
    /* —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ 10x20 –±–ª–æ–∫–æ–≤ */
  }

  #nextCanvas {
    width: 120px;
    height: 120px;
    background: #111827;
    border-radius: 1rem;
    box-shadow: 0 0 15px #22c55e;
  }

  #infoPanel {
    color: #f8fafc;
    font-size: 1.1rem;
    max-width: 120px;
    text-align: center;
    user-select: none;
  }

  #scoreBoard {
    margin-bottom: 1rem;
  }

  button {
    background: linear-gradient(135deg, #2563eb, #1e40af);
    border: none;
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    color: white;
    font-weight: 700;
    border-radius: 0.7rem;
    box-shadow: 0 0 15px #2563eb;
    cursor: pointer;
    user-select: none;
    transition: transform 0.2s ease, box-shadow 0.3s ease;
    margin-top: 1rem;
    width: 120px;
  }

  button:active {
    transform: scale(0.95);
    box-shadow: 0 0 10px #1e40af;
  }

  #pauseOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.75);
    color: #22c55e;
    font-size: 2.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    z-index: 20;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    text-align: center;
    padding: 1rem;
    border-radius: 1rem;
  }
  #pauseOverlay.active {
    opacity: 1;
    pointer-events: all;
  }
</style>
</head>
<body>
<h1>üéÆ –¢–µ—Ç—Ä–∏—Å ‚Äî –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</h1>

<div id="gameContainer">
  <canvas id="tetrisCanvas" width="300" height="600" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ –¢–µ—Ç—Ä–∏—Å–∞" role="img" tabindex="0"></canvas>
  <div id="infoPanel" aria-live="polite" aria-atomic="true">
    <div id="scoreBoard">–°—á–µ—Ç: <strong id="score">0</strong></div>
    <div>–†–µ–∫–æ—Ä–¥: <strong id="highScore">0</strong></div>
    <div style="margin-top:1rem;">–°–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞:</div>
    <canvas id="nextCanvas" width="120" height="120" aria-label="–°–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞"></canvas>
    <button id="btnPause" aria-pressed="false" title="–ü–∞—É–∑–∞/–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å">‚è∏Ô∏è –ü–∞—É–∑–∞</button>
    <button id="btnRestart" title="–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
  </div>
</div>

<div id="pauseOverlay" role="alert" aria-live="assertive" aria-atomic="true"></div>

<!-- –ó–≤—É–∫–∏ -->
<audio id="soundRotate" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
<audio id="soundDrop" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
<audio id="soundLineClear" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
<audio id="soundGameOver" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

<script>
(() => {
  const canvas = document.getElementById('tetrisCanvas');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('nextCanvas');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('highScore');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  // –ó–≤—É–∫–∏
  const soundRotate = document.getElementById('soundRotate');
  const soundDrop = document.getElementById('soundDrop');
  const soundLineClear = document.getElementById('soundLineClear');
  const soundGameOver = document.getElementById('soundGameOver');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = canvas.width / COLS;

  // –¶–≤–µ—Ç–∞ —Ñ–∏–≥—É—Ä –∏ —Ç–µ–Ω–∏
  const COLORS = {
    I: ['#06b6d4', '#0e7490'],
    J: ['#2563eb', '#1e40af'],
    L: ['#f97316', '#b45309'],
    O: ['#eab308', '#a16207'],
    S: ['#22c55e', '#166534'],
    T: ['#8b5cf6', '#5b21b6'],
    Z: ['#ef4444', '#991b1b'],
  };

  // –§–∏–≥—É—Ä—ã –∏ –∏—Ö –≤—Ä–∞—â–µ–Ω–∏—è (–º–∞—Ç—Ä–∏—Ü—ã 4x4)
  const SHAPES = {
    I: [
      [[0,0,0,0],
       [1,1,1,1],
       [0,0,0,0],
       [0,0,0,0]],
      [[0,0,1,0],
       [0,0,1,0],
       [0,0,1,0],
       [0,0,1,0]],
    ],
    J: [
      [[1,0,0],
       [1,1,1],
       [0,0,0]],
      [[0,1,1],
       [0,1,0],
       [0,1,0]],
      [[0,0,0],
       [1,1,1],
       [0,0,1]],
      [[0,1,0],
       [0,1,0],
       [1,1,0]],
    ],
    L: [
      [[0,0,1],
       [1,1,1],
       [0,0,0]],
      [[0,1,0],
       [0,1,0],
       [0,1,1]],
      [[0,0,0],
       [1,1,1],
       [1,0,0]],
      [[1,1,0],
       [0,1,0],
       [0,1,0]],
    ],
    O: [
      [[1,1],
       [1,1]],
    ],
    S: [
      [[0,1,1],
       [1,1,0],
       [0,0,0]],
      [[0,1,0],
       [0,1,1],
       [0,0,1]],
    ],
    T: [
      [[0,1,0],
       [1,1,1],
       [0,0,0]],
      [[0,1,0],
       [0,1,1],
       [0,1,0]],
      [[0,0,0],
       [1,1,1],
       [0,1,0]],
      [[0,1,0],
       [1,1,0],
       [0,1,0]],
    ],
    Z: [
      [[1,1,0],
       [0,1,1],
       [0,0,0]],
      [[0,0,1],
       [0,1,1],
       [0,1,0]],
    ],
  };

  // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ - –º–∞—Å—Å–∏–≤ ROWS x COLS
  let field = [];

  // –¢–µ–∫—É—â–∞—è —Ñ–∏–≥—É—Ä–∞
  let currentPiece = null;
  let currentX = 0;
  let currentY = 0;
  let currentRotation = 0;

  // –°–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞
  let nextPiece = null;

  // –°–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–µ–Ω–∏—è –≤ –º—Å
  let dropInterval = 800;
  let lastDropTime = 0;

  // –°—á–µ—Ç
  let score = 0;
  let highScore = parseInt(localStorage.getItem('tetrisHighScore')) || 0;

  // –°—Ç–∞—Ç—É—Å –∏–≥—Ä—ã
  let isPaused = false;
  let isGameOver = false;

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Å—Ç–æ–≥–æ –ø–æ–ª—è
  function initField() {
    field = [];
    for(let r=0; r<ROWS; r++) {
      field[r] = [];
      for(let c=0; c<COLS; c++) {
        field[r][c] = null;
      }
    }
  }

  // –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–π —Ñ–∏–≥—É—Ä—ã
  function randomPiece() {
    const keys = Object.keys(SHAPES);
    const type = keys[Math.floor(Math.random()*keys.length)];
    return { type, rotation: 0 };
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å —Ñ–∏–≥—É—Ä—É –≤ –ø–æ–∑–∏—Ü–∏–∏
  function canPlace(piece, x, y, rotation) {
    const shape = SHAPES[piece.type][rotation % SHAPES[piece.type].length];
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const newX = x + c;
          const newY = y + r;
          if(newX < 0 || newX >= COLS || newY >= ROWS) return false;
          if(newY >= 0 && field[newY][newX]) return false;
        }
      }
    }
    return true;
  }

  // –ü–æ–º–µ—Å—Ç–∏—Ç—å —Ñ–∏–≥—É—Ä—É –Ω–∞ –ø–æ–ª–µ (–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å)
  function placePiece() {
    const shape = SHAPES[currentPiece.type][currentRotation % SHAPES[currentPiece.type].length];
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentX + c;
          const y = currentY + r;
          if(y >= 0) {
            field[y][x] = currentPiece.type;
          }
        }
      }
    }
  }

  // –£–¥–∞–ª–∏—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏
  function clearLines() {
    let linesCleared = 0;
    for(let r=ROWS-1; r>=0; r--) {
      if(field[r].every(cell => cell !== null)) {
        field.splice(r,1);
        field.unshift(new Array(COLS).fill(null));
        linesCleared++;
        r++; // –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â—É—é –ª–∏–Ω–∏—é, —Ç.–∫. —Å—Ç—Ä–æ–∫–∏ —Å–¥–≤–∏–Ω—É–ª–∏—Å—å –≤–Ω–∏–∑
      }
    }
    if(linesCleared > 0) {
      score += linesCleared * linesCleared * 100;
      if(score > highScore) {
        highScore = score;
        localStorage.setItem('tetrisHighScore', highScore);
      }
      soundLineClear.play();
    }
  }

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –±–ª–æ–∫–∞ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º –∏ —Ç–µ–Ω—å—é
  function drawBlock(x, y, type) {
    const baseColor = COLORS[type][0];
    const shadowColor = COLORS[type][1];
    const px = x * BLOCK_SIZE;
    const py = y * BLOCK_SIZE;

    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç –≤–µ—Ä—Ö–Ω–µ–≥–æ –ª–µ–≤–æ–≥–æ –∫ –Ω–∏–∂–Ω–µ–º—É –ø—Ä–∞–≤–æ–º—É
    const grad = ctx.createLinearGradient(px, py, px+BLOCK_SIZE, py+BLOCK_SIZE);
    grad.addColorStop(0, baseColor);
    grad.addColorStop(1, shadowColor);

    // –¢–µ–Ω—å
    ctx.shadowColor = shadowColor;
    ctx.shadowBlur = 6;
    ctx.fillStyle = grad;
    ctx.fillRect(px+2, py+2, BLOCK_SIZE-4, BLOCK_SIZE-4);

    // –ö–æ–Ω—Ç—É—Ä –±–ª–æ–∫–∞
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#f8fafc80';
    ctx.lineWidth = 2;
    ctx.strokeRect(px+2, py+2, BLOCK_SIZE-4, BLOCK_SIZE-4);
  }

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
  function drawField() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // –§–æ–Ω —Å –ª–µ–≥–∫–æ–π —Ç–µ–∫—Å—Ç—É—Ä–æ–π (–ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –∫–≤–∞–¥—Ä–∞—Ç—ã)
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const px = c * BLOCK_SIZE;
        const py = r * BLOCK_SIZE;

        ctx.fillStyle = '#111827';
        ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

        ctx.strokeStyle = '#37415133';
        ctx.lineWidth = 1;
        ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
      }
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(field[r][c]) {
          drawBlock(c, r, field[r][c]);
        }
      }
    }
  }

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–π —Ñ–∏–≥—É—Ä—ã –Ω–∞ –∏–≥—Ä–æ–≤–æ–º –ø–æ–ª–µ
  function drawCurrentPiece() {
    const shape = SHAPES[currentPiece.type][currentRotation % SHAPES[currentPiece.type].length];
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentX + c;
          const y = currentY + r;
          if(y >= 0) {
            drawBlock(x, y, currentPiece.type);
          }
        }
      }
    }
  }

  // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –º–µ—Å—Ç–∞, –∫—É–¥–∞ —É–ø–∞–¥–µ—Ç —Ñ–∏–≥—É—Ä–∞ (–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –±–ª–æ–∫–∏)
  function drawGhostPiece() {
    let ghostY = currentY;
    while(canPlace(currentPiece, currentX, ghostY+1, currentRotation)) {
      ghostY++;
    }
    ctx.globalAlpha = 0.3;
    const shape = SHAPES[currentPiece.type][currentRotation % SHAPES[currentPiece.type].length];
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentX + c;
          const y = ghostY + r;
          if(y >= 0) {
            drawBlock(x, y, currentPiece.type);
          }
        }
      }
    }
    ctx.globalAlpha = 1;
  }

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã (—É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –º–∞—Å—à—Ç–∞–±)
  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if(!nextPiece) return;

    const shape = SHAPES[nextPiece.type][0];
    const size = shape.length;
    const blockSize = nextCanvas.width / 4;
    const offsetX = (4 - size) / 2 * blockSize;
    const offsetY = (4 - size) / 2 * blockSize;

    nextCtx.shadowColor = COLORS[nextPiece.type][1];
    nextCtx.shadowBlur = 6;

    for(let r=0; r<size; r++) {
      for(let c=0; c<size; c++) {
        if(shape[r][c]) {
          const px = offsetX + c * blockSize;
          const py = offsetY + r * blockSize;

          const grad = nextCtx.createLinearGradient(px, py, px+blockSize, py+blockSize);
          grad.addColorStop(0, COLORS[nextPiece.type][0]);
          grad.addColorStop(1, COLORS[nextPiece.type][1]);

          nextCtx.fillStyle = grad;
          nextCtx.fillRect(px+2, py+2, blockSize-4, blockSize-4);

          nextCtx.strokeStyle = '#f8fafc80';
          nextCtx.lineWidth = 2;
          nextCtx.strokeRect(px+2, py+2, blockSize-4, blockSize-4);
        }
      }
    }

    nextCtx.shadowBlur = 0;
  }

  // –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Ñ–∏–≥—É—Ä—É –≤–Ω–∏–∑, –µ—Å–ª–∏ –Ω–µ–ª—å–∑—è - –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∏ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é
  function dropPiece() {
    if(canPlace(currentPiece, currentX, currentY+1, currentRotation)) {
      currentY++;
      soundDrop.play();
      return true;
    } else {
      placePiece();
      clearLines();
      spawnNewPiece();
      return false;
    }
  }

  // –ü–æ—è–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
  function spawnNewPiece() {
    currentPiece = nextPiece || randomPiece();
    currentX = Math.floor((COLS - SHAPES[currentPiece.type][0].length) / 2);
    currentY = -getTopEmptyRows(currentPiece.type, currentRotation);
    currentRotation = 0;
    nextPiece = randomPiece();

    if(!canPlace(currentPiece, currentX, currentY, currentRotation)) {
      isGameOver = true;
      soundGameOver.play();
      showPauseOverlay("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n–ù–∞–∂–º–∏ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ");
    }

    updateScoreBoard();
  }

  // –°–∫–æ–ª—å–∫–æ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ —Å–≤–µ—Ä—Ö—É —É —Ñ–∏–≥—É—Ä—ã (–¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è)
  function getTopEmptyRows(type, rotation) {
    const shape = SHAPES[type][rotation % SHAPES[type].length];
    let count = 0;
    for(let r=0; r<shape.length; r++) {
      if(shape[r].every(cell => cell === 0)) count++;
      else break;
    }
    return count;
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç–∞ –∏ —Ä–µ–∫–æ—Ä–¥–∞
  function updateScoreBoard() {
    scoreEl.textContent = score;
    highScoreEl.textContent = highScore;
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∞–≤–∏—à
  function handleKeyDown(e) {
    if(isPaused || isGameOver) return;

    switch(e.key) {
      case 'ArrowLeft':
      case 'a':
      case 'A':
        if(canPlace(currentPiece, currentX-1, currentY, currentRotation)) {
          currentX--;
          e.preventDefault();
        }
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        if(canPlace(currentPiece, currentX+1, currentY, currentRotation)) {
          currentX++;
          e.preventDefault();
        }
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        if(canPlace(currentPiece, currentX, currentY+1, currentRotation)) {
          currentY++;
          score++; // –±–æ–Ω—É—Å –∑–∞ —É—Å–∫–æ—Ä–µ–Ω–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ
          e.preventDefault();
          soundDrop.play();
        }
        break;
      case 'ArrowUp':
      case 'w':
      case 'W':
      case 'x':
      case 'X':
        // –í—Ä–∞—â–µ–Ω–∏–µ
        rotatePiece();
        e.preventDefault();
        break;
      case ' ':
        // –ë—ã—Å—Ç—Ä–æ–µ –ø–∞–¥–µ–Ω–∏–µ
        hardDrop();
        e.preventDefault();
        break;
    }
  }

  // –í—Ä–∞—â–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∏ —Å–¥–≤–∏–≥–æ–º (Wall kick)
  function rotatePiece() {
    const newRotation = (currentRotation + 1) % SHAPES[currentPiece.type].length;
    if(canPlace(currentPiece, currentX, currentY, newRotation)) {
      currentRotation = newRotation;
      soundRotate.play();
    } else {
      // Wall kick: –ø—Ä–æ–±—É–µ–º —Å–¥–≤–∏–Ω—É—Ç—å —Ñ–∏–≥—É—Ä—É –≤–ª–µ–≤–æ –∏–ª–∏ –≤–ø—Ä–∞–≤–æ –Ω–∞ 1
      if(canPlace(currentPiece, currentX-1, currentY, newRotation)) {
        currentX--;
        currentRotation = newRotation;
        soundRotate.play();
      } else if(canPlace(currentPiece, currentX+1, currentY, newRotation)) {
        currentX++;
        currentRotation = newRotation;
        soundRotate.play();
      }
    }
  }

  // –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ –≤–Ω–∏–∑
  function hardDrop() {
    while(canPlace(currentPiece, currentX, currentY+1, currentRotation)) {
      currentY++;
      score += 2;
    }
    placePiece();
    clearLines();
    spawnNewPiece();
    soundDrop.play();
  }

  // –ü–∞—É–∑–∞ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–≤–µ—Ä–ª–µ—è
  function togglePause() {
    if(isGameOver) return;
    isPaused = !isPaused;
    btnPause.textContent = isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '‚è∏Ô∏è –ü–∞—É–∑–∞';
    btnPause.setAttribute('aria-pressed', isPaused.toString());
    if(isPaused) {
      showPauseOverlay("–ü–∞—É–∑–∞");
    } else {
      hidePauseOverlay();
      lastDropTime = performance.now();
      requestAnimationFrame(gameLoop);
    }
  }

  // –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–≤–µ—Ä–ª–µ–π –ø–∞—É–∑—ã/–∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
  function showPauseOverlay(text) {
    pauseOverlay.textContent = text;
    pauseOverlay.classList.add('active');
  }

  // –°–∫—Ä—ã—Ç—å –æ–≤–µ—Ä–ª–µ–π
  function hidePauseOverlay() {
    pauseOverlay.classList.remove('active');
  }

  // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏–≥—Ä—ã
  function restartGame() {
    isGameOver = false;
    isPaused = false;
    score = 0;
    initField();
    spawnNewPiece();
    updateScoreBoard();
    btnPause.textContent = '‚è∏Ô∏è –ü–∞—É–∑–∞';
    btnPause.setAttribute('aria-pressed', 'false');
    hidePauseOverlay();
    lastDropTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∏–≥—Ä—ã
  function gameLoop(time = 0) {
    if(isPaused || isGameOver) return;

    if(time - lastDropTime > dropInterval) {
      if(!dropPiece()) {
        // –§–∏–≥—É—Ä–∞ –Ω–µ —É–ø–∞–ª–∞ ‚Äî –∑–Ω–∞—á–∏—Ç –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ –∏ –ø–æ—è–≤–∏–ª–∞—Å—å –Ω–æ–≤–∞—è
      }
      lastDropTime = time;
    }

    drawField();
    drawGhostPiece();
    drawCurrentPiece();
    drawNextPiece();

    updateScoreBoard();

    requestAnimationFrame(gameLoop);
  }

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  function init() {
    initField();
    spawnNewPiece();
    updateScoreBoard();
    lastDropTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  // –°–ª—É—à–∞—Ç–µ–ª–∏
  window.addEventListener('keydown', handleKeyDown);
  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', restartGame);

  init();
})();
</script>

</body>
</html>
